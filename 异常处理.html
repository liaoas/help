<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2024-01-24T10:09:25.1889985"><meta name="build-number" content="${buildNumber}">       <title>异常处理 | Spring Batch</title><script id="virtual-toc-data" type="application/json">[{"id":"d706b7d7_921","level":0,"title":"项目搭建","anchor":"#d706b7d7_921"},{"id":"d706b7d7_926","level":0,"title":"启动类","anchor":"#d706b7d7_926"},{"id":"d706b7d7_931","level":0,"title":"数据库准备","anchor":"#d706b7d7_931"},{"id":"d706b7d7_934","level":0,"title":"项目配置","anchor":"#d706b7d7_934"},{"id":"d706b7d7_938","level":0,"title":"默认异常处理","anchor":"#d706b7d7_938"},{"id":"d706b7d7_950","level":0,"title":"异常重试","anchor":"#d706b7d7_950"},{"id":"d706b7d7_974","level":0,"title":"异常跳过","anchor":"#d706b7d7_974"},{"id":"d706b7d7_996","level":0,"title":"事务问题","anchor":"#d706b7d7_996"},{"id":"d706b7d7_1016","level":0,"title":"重启机制","anchor":"#d706b7d7_1016"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="异常处理 | Spring Batch"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Spring Batch Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="异常处理.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="异常处理 | Spring Batch"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "异常处理.html#webpage", "url": "异常处理.html", "name": "异常处理 | Spring Batch", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Spring Batch Help" }</script><!-- End Schema.org --></head>      <body data-id="异常处理" data-main-title="异常处理" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs=""  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Spring Batch  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="异常处理"   id="异常处理.md">异常处理</h1>  <p id="d706b7d7_909">Spring Batch 处理任务过程中，如果遇到了异常，默认机制是马上停止任务执行，抛出相应异常。如果任务还有未执行的步骤也不会执行。若要改变这个规则，可以配置 <span class="control" id="d706b7d7_910">异常重试</span> 和 <span class="control" id="d706b7d7_911">异常跳过</span> 机制。</p><ul class="list _ul" id="d706b7d7_912"><li class="list__item" id="d706b7d7_913"><p id="d706b7d7_914"><span class="control" id="d706b7d7_915">异常跳过</span></p><p id="d706b7d7_916">遇到异常的时候不希望结束任务，而是跳过这个异常，继续执行</p></li><li class="list__item" id="d706b7d7_917"><p id="d706b7d7_918"><span class="control" id="d706b7d7_919">异常重试</span></p><p id="d706b7d7_920">遇到异常时经过指定次数的重试，如果还是失败的话，才会停止任务。</p></li></ul><section class="chapter"><h2 id="d706b7d7_921" data-toc="d706b7d7_921"   >项目搭建</h2><p id="d706b7d7_922">新建一个 Spring Boot 项目 版本为 <code class="code" id="d706b7d7_923">2.7.12-SNAPSHOT</code> ，项目名称为： <code class="code" id="d706b7d7_924">spring-boot-batch-exception</code> ，Maven 依赖项如下：</p><div class="code-block" data-lang="markup"         >
		&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-batch&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.32&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
</div></section><section class="chapter"><h2 id="d706b7d7_926" data-toc="d706b7d7_926"   >启动类</h2><p id="d706b7d7_927"><code class="code" id="d706b7d7_928">Spring Boot</code> 启动类添加 <code class="code" id="d706b7d7_929">@EnableBatchProcessing</code></p><div class="code-block" data-lang="java"         >
@EnableBatchProcessing
@SpringBootApplication
public class AppApplication {

    public static void main(String[] args) {
        SpringApplication.run(AppApplication.class, args);
    }

}
</div></section><section class="chapter"><h2 id="d706b7d7_931" data-toc="d706b7d7_931"   >数据库准备</h2><p id="d706b7d7_932">准备一个 MySQL 数据库，用于持久化 Spring Batch 的任务，新建一个数据库，数据库命名为 <code class="code" id="d706b7d7_933">spring_batch_test</code> 并导入 Spring Batch 所用到的数据表，org.springframework.batch.core目录下的schema-mysql.sql文件：</p></section><section class="chapter"><h2 id="d706b7d7_934" data-toc="d706b7d7_934"   >项目配置</h2><p id="d706b7d7_935">配置项目的数据库连接信息如下：</p><div class="code-block" data-lang="yaml"         >
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/spring_batch_test
    username: root
    password: liao

</div><p id="d706b7d7_937">至此，基本框架搭建好了，下面开始配置一个简单的任务。</p></section><section class="chapter"><h2 id="d706b7d7_938" data-toc="d706b7d7_938"   >默认异常处理</h2><p id="d706b7d7_939">新建任务测试类 <code class="code" id="d706b7d7_940">DefaultExceptionJobDemo</code> ，用于测试默认情况下 Spring Batch 下默认处理异常机制</p><div class="code-block" data-lang="java"         >
package com.liao.job;

/**
 * &lt;p&gt;
 * Spring Batch 默认异常处理测试
 * &lt;/p&gt;
 *
 * @author LiAo
 * @since 2023-07-13
 */
@Configuration
public class DefaultExceptionJobDemo {

    @Resource
    private JobBuilderFactory jobBuilderFactory;

    @Resource
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    public Job defaultExceptionJob() {
        return jobBuilderFactory.get(&quot;defaultExceptionJob&quot;)
                .start(
                        stepBuilderFactory.get(&quot;defaultExceptionStep&quot;)
                                .tasklet((stepContribution, chunkContext) -&gt; {
                                    ExecutionContext execution = chunkContext.getStepContext().getStepExecution().getExecutionContext();
                                    if (execution.containsKey(&quot;success&quot;)) {
                                        System.out.println(&quot;任务执行成功&quot;);
                                        return RepeatStatus.FINISHED;
                                    } else {
                                        String errorMessage = &quot;处理任务过程发生异常&quot;;
                                        System.out.println(errorMessage);
                                        execution.put(&quot;success&quot;, true);
                                        throw new RuntimeException(errorMessage);
                                    }
                                }).build()
                ).build();
    }
}
</div><p id="d706b7d7_942">上述代码，在 Step 的 tasklet() 函数中获取执行上下文，并判断 上下文中是否包含 success，如果包含则执行成功；如果不包含，则抛出异常，并在抛出异常前在上下文中添加 &ldquo;success&rdquo; 这个 key。</p><p id="d706b7d7_943">启动项目，控制台打印如下：</p><div class="code-block" data-lang="java"         >
2023-07-13 16:58:16.941  INFO 19100 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [defaultExceptionStep]
处理任务过程发生异常
2023-07-13 16:58:16.956 ERROR 19100 --- [           main] o.s.batch.core.step.AbstractStep         : Encountered an error executing step defaultExceptionStep in job defaultExceptionJob

java.lang.RuntimeException: 处理任务过程发生异常
	at com.liao.job.DefaultExceptionJobDemo.lambda$defaultExceptionJob$0(DefaultExceptionJobDemo.java:45) ~[classes/:na]
	at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:407) ~[spring-batch-core-4.3.8.jar:4.3.8]
	at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:331) ~[spring-batch-core-4.3.8.jar:4.3.8]
	at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:140) ~[spring-tx-5.3.27.jar:5.3.27]
	at org.springframework.batch.core.step.tasklet.TaskletStep$2.doInChunkContext(TaskletStep.java:273) ~[spring-batch-core-4.3.8.jar:4.3.8]
	at org.springframework.batch.core.scope.context.StepContextRepeatCallback.doInIteration(StepContextRepeatCallback.java:82) ~[spring-batch-core-4.3.8.jar:4.3.8]
</div><p id="d706b7d7_945">根据上述控制台打印来看，Spring Batch 执行任务时如果发生了异常会马上停止任务的执行</p><p id="d706b7d7_946">再次启动项目打印如下：</p><div class="code-block" data-lang="java"         >
2023-07-13 17:05:44.309  INFO 2128 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [defaultExceptionStep]
任务执行成功
2023-07-13 17:05:44.323  INFO 2128 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [defaultExceptionStep] executed in 14ms
2023-07-13 17:05:44.331  INFO 2128 --- [           main] o.s.b.c.l.support.SimpleJobLauncher      : Job: [SimpleJob: [name=defaultExceptionJob]] completed with the following parameters: [{}] and the following status: [COMPLETED] in 34ms
</div><p id="d706b7d7_948">因为在上次任务抛出异常前，我们在执行上下文中添加 <code class="code" id="d706b7d7_949">success</code> key（配合MySQL持久化，不会因项目启动而丢失）。</p></section><section class="chapter"><h2 id="d706b7d7_950" data-toc="d706b7d7_950"   >异常重试</h2><p id="d706b7d7_951">Spring Batch 允许配置任务遇到指定异常时的重试次数。在此之前。需要先定义一个异常 <code class="code" id="d706b7d7_952">MyJobExecutionException</code></p><div class="code-block" data-lang="java"         >
package com.liao.exception;

/**
 * &lt;p&gt;
 * 自定义异常
 * &lt;/p&gt;
 *
 * @author LiAo
 * @since 2023-07-14
 */
public class MyJobExecutionException extends Exception {

    private static final long serialVersionUID = 7168487913507656106L;

    public MyJobExecutionException(String message) {
        super(message);
    }
}
</div><p id="d706b7d7_954">然后新建异常重试测试任务类 <code class="code" id="d706b7d7_955">RetryExceptionJobDemo</code></p><div class="code-block" data-lang="java"         >
package com.liao.job;

/**
 * &lt;p&gt;
 * Spring Batch 异常重试测试
 * &lt;/p&gt;
 *
 * @author LiAo
 * @since 2023-07-14
 */
@Configuration
public class RetryExceptionJobDemo {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    public Job job(@Qualifier(&quot;RetryExceptionStep&quot;) Step step) {
        return jobBuilderFactory.get(&quot;RetryExceptionJob&quot;)
                .start(step)
                .build();
    }

    @Bean(&quot;RetryExceptionStep&quot;)
    public Step step(@Qualifier(&quot;RetryExceptionItemReader&quot;) ListItemReader&lt;String&gt; listItemReader,
                     @Qualifier(&quot;RetryExceptionProcessor&quot;) ItemProcessor&lt;String, String&gt; processor) {
        return stepBuilderFactory.get(&quot;RetryExceptionStep&quot;)
                .&lt;String, String&gt;chunk(2)
                .reader(listItemReader)
                .processor(processor)
                .writer(items -&gt; items.forEach(System.out::println))
                .faultTolerant() // 配置错误容忍
                .retry(MyJobExecutionException.class) // 配置异常类型
                // 重试次数，三次过后还会异常，则结束任务
                // 异常的次数为reader，processor和writer中的总数，这里仅在processor里演示异常重试
                .retryLimit(3)
                .build();
    }

    @Bean(&quot;RetryExceptionItemReader&quot;)
    public ListItemReader&lt;String&gt; listItemReader() {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();

        IntStream.range(0, 5).forEach(i -&gt; list.add(String.valueOf(i)));

        return new ListItemReader&lt;&gt;(list);
    }

    @Bean(&quot;RetryExceptionProcessor&quot;)
    public ItemProcessor&lt;String, String&gt; myProcessor() {
        return new ItemProcessor&lt;String, String&gt;() {
            private int count;

            @Override
            public String process(String item) throws Exception {
                System.out.println(&quot;当前处理的数据：&quot; + item);
                if (count &gt;= 2) {
                    return item;
                } else {
                    count++;
                    throw new MyJobExecutionException(&quot;任务处理出错&quot;);
                }
            }

        };
    }
}
</div><p id="d706b7d7_957">在 <code class="code" id="d706b7d7_958">step()</code> 函数中， <code class="code" id="d706b7d7_959">faultTolerant()</code> 函数表示开启容错功能， <code class="code" id="d706b7d7_960">retry(MyJobExecutionException.class)</code> 表示遇到 <code class="code" id="d706b7d7_961">MyJobExecutionException</code> 异常时进行重试</p><p id="d706b7d7_962"><code class="code" id="d706b7d7_963">myProcessor()</code> 函数的代码逻辑是：在前两次的时候抛出 <code class="code" id="d706b7d7_964">MyJobExecutionException(&quot;任务处理出错&quot;)</code> 的异常，第三次的时候正常返回 <code class="code" id="d706b7d7_965">item</code> ，理论上，上述任务在报错重试两次之后正常运行。</p><p id="d706b7d7_966">启动项目，日志打印如下：</p><div class="code-block" data-lang="java"         >
2023-07-14 11:05:45.923  INFO 13420 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [SkipExceptionStep1689303945313]
当前处理的数据：0
当前处理的数据：0
当前处理的数据：0
当前处理的数据：1
0
1
当前处理的数据：2
当前处理的数据：3
2
3
当前处理的数据：4
4
2023-07-14 11:05:45.950  INFO 13420 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [SkipExceptionStep1689303945313] executed in 27ms
</div><p id="d706b7d7_968">若是把 <code class="code" id="d706b7d7_969">retryLimit</code> 改为 <code class="code" id="d706b7d7_970">retryLimit(2)</code> ，并修改任务名称为 <code class="code" id="d706b7d7_971">RetryExceptionJob01</code> ，启动项目再次测试运行结果，如下：</p><div class="code-block" data-lang="java"         >
2023-07-26 17:16:28.526  INFO 24760 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [RetryExceptionStep1690362987642]
当前处理的数据：0
当前处理的数据：0
2023-07-26 17:16:28.549 ERROR 24760 --- [           main] o.s.batch.core.step.AbstractStep         : Encountered an error executing step RetryExceptionStep1690362987642 in job RetryExceptionJob01

org.springframework.retry.RetryException: Non-skippable exception in recoverer while processing; nested exception is com.liao.exception.MyJobExecutionException: 任务处理出错
	at org.springframework.batch.core.step.item.FaultTolerantChunkProcessor$2.recover(FaultTolerantChunkProcessor.java:299) ~[spring-batch-core-4.3.8.jar:4.3.8]
</div><p id="d706b7d7_973">上述结果是异常重试超过了重试次数，抛出了异常</p></section><section class="chapter"><h2 id="d706b7d7_974" data-toc="d706b7d7_974"   >异常跳过</h2><p id="d706b7d7_975">可以在 Step 中配置异常跳过，即遇到指定类型的异常时忽略跳过他，首先新建自定义 <code class="code" id="d706b7d7_976">SkipListener</code> 监听器 <code class="code" id="d706b7d7_977">MySkipListener</code> 用于打印异常跳过时的异常信息：</p><div class="code-block" data-lang="java"         >
package com.liao.listener;

/**
 * &lt;p&gt;
 * Skip 类型监听器
 * &lt;/p&gt;
 *
 * @author LiAo
 * @since 2023-07-26
 */
@Component
public class MySkipListener implements SkipListener&lt;String, String&gt; {

    @Override
    public void onSkipInRead(Throwable t) {
        System.out.println(&quot;在读取数据的时候遇到异常并跳过，异常：&quot; + t.getMessage());
    }

    @Override
    public void onSkipInWrite(String item, Throwable t) {
        System.out.println(&quot;在输出数据的时候遇到异常并跳过，待输出数据：&quot; + item + &quot;，异常：&quot; + t.getMessage());
    }

    @Override
    public void onSkipInProcess(String item, Throwable t) {
        System.out.println(&quot;在处理数据的时候遇到异常并跳过，待输出数据：&quot; + item + &quot;，异常：&quot; + t.getMessage());
    }
}
</div><p id="d706b7d7_979">上述新建了一个自定义监听器，用于打印遇到异常时的 值 和 和异常信息</p><p id="d706b7d7_980">新建测试类 <code class="code" id="d706b7d7_981">SkipExceptionJobDemo</code> 用于测试 异常跳过</p><div class="code-block" data-lang="java"         >
package com.liao.job;

/**
 * &lt;p&gt;
 * Spring Boot 异常跳过测试
 * &lt;/p&gt;
 *
 * @author LiAo
 * @since 2023-07-26
 */
@Configuration
public class SkipExceptionJobDemo {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Autowired
    private MySkipListener mySkipListener;

    @Bean
    public Job skipExceptionJob(@Qualifier(&quot;SkipExceptionStep&quot;) Step step) {
        return jobBuilderFactory.get(&quot;skipExceptionJob&quot; + System.currentTimeMillis())
                .start(step)
                .build();
    }

    @Bean(&quot;SkipExceptionStep&quot;)
    public Step step(@Qualifier(&quot;SkipExceptionProcessor&quot;) ItemProcessor&lt;String, String&gt; processor,
                     @Qualifier(&quot;SkipExceptionReader&quot;) ListItemReader&lt;String&gt; reader) {
        return stepBuilderFactory.get(&quot;skipExceptionStep&quot;)
                .&lt;String, String&gt;chunk(2)
                .reader(reader)
                .processor(processor)
                .writer(items -&gt; items.forEach(System.out::println))
                .faultTolerant()//配置错误容忍
                .skip(MyJobExecutionException.class)// 配置跳过的异常类型
                // 异常的次数为reader，processor和writer中的总数，这里仅在processor里演示异常跳过
                .skipLimit(1)// 最多跳过1次，1次过后还是异常的话，则任务会结束，
                // 自定义监听器，用于打印异常信息
                .listener(mySkipListener)
                .build();
    }

    @Bean(&quot;SkipExceptionReader&quot;)
    public ListItemReader&lt;String&gt; listItemReader() {
        List&lt;String&gt; strings = new ArrayList&lt;&gt;();

        IntStream.range(0, 5).forEach(i -&gt; strings.add(String.valueOf(i)));

        return new ListItemReader&lt;&gt;(strings);
    }

    @Bean(&quot;SkipExceptionProcessor&quot;)
    public ItemProcessor&lt;String, String&gt; myProcessor() {
        return item -&gt; {
            System.out.println(&quot;当前处理的数据&quot; + item);
            if (&quot;2&quot;.equals(item)) {
                throw new MyJobExecutionException(&quot;任务处理出错&quot;);
            } else {
                return item;
            }
        };
    }
}
</div><p id="d706b7d7_983">在 <code class="code" id="d706b7d7_984">step()</code> 函数中， <code class="code" id="d706b7d7_985">faultTolerant()</code> 表示开启容错功能， <code class="code" id="d706b7d7_986">skip(MyJobExecutionException.class)</code> 表示遇到 <code class="code" id="d706b7d7_987">MyJobExecutionException</code> 异常时跳过， <code class="code" id="d706b7d7_988">skipLimit(1)</code> 表示只跳过一次。</p><p id="d706b7d7_989"><code class="code" id="d706b7d7_990">myProcessor()</code> 的逻辑时，当处理的 item 值为 &ldquo;2&rdquo; 的时候，抛出 <code class="code" id="d706b7d7_991">MyJobExecutionException(&quot;任务处理出错&quot;)</code> 的异常。</p><p id="d706b7d7_992"><code class="code" id="d706b7d7_993">listener(mySkipListener)</code> 用于注入一个自定义的监听器</p><p id="d706b7d7_994">启动项目，日志打印如下：</p><div class="code-block" data-lang="java"         >
2023-07-27 14:57:59.417  INFO 8184 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [skipExceptionStep]
当前处理的数据0
当前处理的数据1
0
1
当前处理的数据2
当前处理的数据3
3
在处理数据的时候遇到异常并跳过，待输出数据：2，异常：任务处理出错
当前处理的数据4
4
2023-07-27 14:57:59.436  INFO 8184 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [skipExceptionStep] executed in 19ms
</div></section><section class="chapter"><h2 id="d706b7d7_996" data-toc="d706b7d7_996"   >事务问题</h2><p id="d706b7d7_997">一次 <span class="control" id="d706b7d7_998">Step</span> 分为 <span class="control" id="d706b7d7_999">Reader</span>、 <span class="control" id="d706b7d7_1000">Processor</span>、 <span class="control" id="d706b7d7_1001">Writer</span> 三个阶段，这些阶段统称为 <span class="control" id="d706b7d7_1002">Itme</span> 。默认情况下如果错误不是发生在 <span class="control" id="d706b7d7_1003">Reader</span> 阶段，那么就没必要重新去读取一次数据。但是某些场景下 <span class="control" id="d706b7d7_1004">Reader</span> 部分也需要重新执行，比如 <span class="control" id="d706b7d7_1005">Reader</span> 是从一个 <span class="control" id="d706b7d7_1006">JMS</span> 队列中消费消息，当发生回滚的时候也会在队列上重放，因此也要将 <span class="control" id="d706b7d7_1007">Reader</span> 纳入到回滚的事务中，根据这个场景可以使用 <code class="code" id="d706b7d7_1008">readerIsTransactionalQueue()</code> 来配置数据重读。</p><div class="code-block" data-lang="java"         >
private Step step() {
    return stepBuilderFactory.get(&quot;step&quot;)
            .&lt;String, String&gt;chunk(2)
            .reader(listItemReader())
            .writer(list -&gt; list.forEach(System.out::println))
            .readerIsTransactionalQueue() // 消息队列数据重读
            .build();
}
</div><p id="d706b7d7_1010">也可以在 <code class="code" id="d706b7d7_1011">Step</code> 中手动配置事务属性，事物的属性包括 <span class="control" id="d706b7d7_1012">隔离等级</span> （isolation）、 <span class="control" id="d706b7d7_1013">传播方式</span> （propagation）以及 <span class="control" id="d706b7d7_1014">过期时间</span> （timeout）等：</p><div class="code-block" data-lang="java"         >
private Step step() {
    DefaultTransactionAttribute attribute = new DefaultTransactionAttribute();
    attribute.setPropagationBehavior(Propagation.REQUIRED.value());
    attribute.setIsolationLevel(Isolation.DEFAULT.value());
    attribute.setTimeout(30);

    return stepBuilderFactory.get(&quot;step&quot;)
            .&lt;String, String&gt;chunk(2)
            .reader(listItemReader())
            .writer(list -&gt; list.forEach(System.out::println))
            .transactionAttribute(attribute)
            .build();
}
</div></section><section class="chapter"><h2 id="d706b7d7_1016" data-toc="d706b7d7_1016"   >重启机制</h2><p id="d706b7d7_1017">默认情况下，任务执行完毕的状态为 COMPLETED ，再次启动项目，该任务的 Step 不会再次执行，我们可以配置 <code class="code" id="d706b7d7_1018">allowStartIfComplete(true)</code> 来实现每次项目启动都执行这个 <span class="control" id="d706b7d7_1019">Step:</span></p><div class="code-block" data-lang="java"         >
private Step step() {
    return stepBuilderFactory.get(&quot;step&quot;)
            .&lt;String, String&gt;chunk(2)
            .reader(listItemReader())
            .writer(list -&gt; list.forEach(System.out::println))
            .allowStartIfComplete(true)
            .build();
}
</div><p id="d706b7d7_1021">某些 <span class="control" id="d706b7d7_1022">Step</span> 可能用于处理一些先决的任务，所以当 <span class="control" id="d706b7d7_1023">Job</span> 再次重启时这 <code class="code" id="d706b7d7_1024">Step</code> 就没必要再执行，可以通过设置 <code class="code" id="d706b7d7_1025">startLimit()</code> 来限定某个 <span class="control" id="d706b7d7_1026">Step</span> 重启的次数。当设置为 1 时候表示仅仅运行一次，而出现重启时将不再执行：</p><div class="code-block" data-lang="java"         >
private Step step() {
    return stepBuilderFactory.get(&quot;step&quot;)
            .&lt;String, String&gt;chunk(2)
            .reader(listItemReader())
            .writer(list -&gt; list.forEach(System.out::println))
            .startLimit(1)
            .build();
}
</div></section><div class="last-modified"> Last modified: 24 一月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="监听器.html">监听器</a>   <a class="navigation-links__next" href="任务调度.html">任务调度</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>