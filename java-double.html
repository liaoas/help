<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2024-01-24T10:09:25.1909975"><meta name="build-number" content="${buildNumber}">       <title>开始吧 | Spring Batch</title><script id="virtual-toc-data" type="application/json">[{"id":"4b23c91b_1662","level":0,"title":"项目搭建","anchor":"#4b23c91b_1662"},{"id":"4b23c91b_1667","level":0,"title":"启动类","anchor":"#4b23c91b_1667"},{"id":"4b23c91b_1672","level":0,"title":"数据库准备","anchor":"#4b23c91b_1672"},{"id":"4b23c91b_1675","level":0,"title":"项目配置","anchor":"#4b23c91b_1675"},{"id":"4b23c91b_1679","level":0,"title":"编写任务","anchor":"#4b23c91b_1679"},{"id":"4b23c91b_1699","level":0,"title":"多步骤任务","anchor":"#4b23c91b_1699"},{"id":"4b23c91b_1717","level":0,"title":"多步骤任务状态判断","anchor":"#4b23c91b_1717"},{"id":"4b23c91b_1724","level":0,"title":"注意","anchor":"#4b23c91b_1724"},{"id":"spring-batch-4-2-5-release","level":0,"title":"Spring Batch 4.2.5.RELEASE 代码变动","anchor":"#spring-batch-4-2-5-release"},{"id":"flow","level":0,"title":"Flow 任务","anchor":"#flow"},{"id":"4b23c91b_1756","level":0,"title":"并行任务","anchor":"#4b23c91b_1756"},{"id":"4b23c91b_1768","level":0,"title":"任务决策器","anchor":"#4b23c91b_1768"},{"id":"4b23c91b_1770","level":0,"title":"决策器创建","anchor":"#4b23c91b_1770"},{"id":"4b23c91b_1782","level":0,"title":"决策器使用","anchor":"#4b23c91b_1782"},{"id":"4b23c91b_1797","level":0,"title":"嵌套任务","anchor":"#4b23c91b_1797"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="开始吧 | Spring Batch"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Spring Batch Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="java-double.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="开始吧 | Spring Batch"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "java-double.html#webpage", "url": "java-double.html", "name": "开始吧 | Spring Batch", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Spring Batch Help" }</script><!-- End Schema.org --></head>      <body data-id="Java-Double" data-main-title="开始吧" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs=""  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Spring Batch  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Java-Double"   id="Java-Double.md">开始吧</h1>  <section class="chapter"><h2 id="4b23c91b_1662" data-toc="4b23c91b_1662"   >项目搭建</h2><p id="4b23c91b_1663">新建一个 Spring Boot 项目 版本为 <code class="code" id="4b23c91b_1664">2.7.12-SNAPSHOT</code> ，项目名称为： <code class="code" id="4b23c91b_1665">spring-boot-batch</code> ，Maven 依赖项如下所示：</p><div class="code-block" data-lang="markup"         >
	&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-batch&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.32&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.batch&lt;/groupId&gt;
            &lt;artifactId&gt;spring-batch-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</div></section><section class="chapter"><h2 id="4b23c91b_1667" data-toc="4b23c91b_1667"   >启动类</h2><p id="4b23c91b_1668"><code class="code" id="4b23c91b_1669">Spring Boot</code> 启动类添加 <code class="code" id="4b23c91b_1670">@EnableBatchProcessing</code></p><div class="code-block" data-lang="java"         >
@EnableBatchProcessing
@SpringBootApplication
public class AppApplication {

    public static void main(String[] args) {
        SpringApplication.run(AppApplication.class, args);
    }

}
</div></section><section class="chapter"><h2 id="4b23c91b_1672" data-toc="4b23c91b_1672"   >数据库准备</h2><p id="4b23c91b_1673">准备一个 MySQL 数据库，用于持久化 Spring Batch 的任务，新建一个数据库，数据库命名为 <code class="code" id="4b23c91b_1674">spring_batch_test</code> 并导入 Spring Batch 所用到的数据表，org.springframework.batch.core目录下的schema-mysql.sql文件：</p></section><section class="chapter"><h2 id="4b23c91b_1675" data-toc="4b23c91b_1675"   >项目配置</h2><p id="4b23c91b_1676">配置项目的数据库连接信息如下：</p><div class="code-block" data-lang="yaml"         >
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/spring_batch_test
    username: root
    password: liao
</div><p id="4b23c91b_1678">至此，基本框架搭建好了，下面开始配置一个简单的任务。</p></section><section class="chapter"><h2 id="4b23c91b_1679" data-toc="4b23c91b_1679"   >编写任务</h2><p id="4b23c91b_1680">新建 job 包，并新建一个任务类如下：</p><div class="code-block" data-lang="java"         >
package com.liao.job;

/**
 * &lt;p&gt;
 * 测试执行单个步骤任务
 * &lt;/p&gt;
 *
 * @author LiAo
 * @since 2023-05-11
 */
@Component
public class FirstJobDemo {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    public Job firstJob01() {
        return jobBuilderFactory.get(&quot;firstJob01&quot;).start(step01()).build();
    }

    public Step step01() {
        return stepBuilderFactory.get(&quot;step01&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;Spring Batch 执行第一个步骤...&quot;);
            // 处理完成
            return RepeatStatus.FINISHED;
        }).build();
    }
}
</div><p id="4b23c91b_1682">上述代码使用， <code class="code" id="4b23c91b_1683">JobBuilderFactory</code> 任务工厂和 <code class="code" id="4b23c91b_1684">StepBuilderFactory</code> 步骤工厂，分别用于创建，任务和步骤， <code class="code" id="4b23c91b_1685">JobBuilderFactory.get</code> 创建一个具体的任务名称， <code class="code" id="4b23c91b_1686">start</code> 方法用于指定开始步骤，步骤通过 <code class="code" id="4b23c91b_1687">StepBuilderFactory</code> 构建。步骤 Step 由若干个小任务 Testklet 组成。通过 tasklet 方法创建任务，tasklet 方法接收一个 Tasklet 类型的参数，Tasklet 是一个函数式接口，源码如下：</p><div class="code-block" data-lang="java"         >
public interface Tasklet {
		@Nullable
		RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception;
}
</div><p id="4b23c91b_1689">所以可以使用 Lambda 表达式实现 Tasklet 匿名函数的创建：</p><div class="code-block" data-lang="java"         >
(contribution, chunkContext) -&gt; {
		System.out.println(&quot;Spring Batch 执行第一个步骤...&quot;);
		// 处理完成
		return RepeatStatus.FINISHED;
}
</div><p id="4b23c91b_1691">该匿名函数返回值为 RepeatStatus ，表示任务的执行状态，这里使用 <code class="code" id="4b23c91b_1692">RepeatStatus.FINISHED</code> 表示该小任务执行完成，正常结束。</p><p id="4b23c91b_1693">配置的任务必须注册到 Spring IOC 容器中，并且任务名称和步骤名称必须唯一。比如上面的例子，任务名称为 <code class="code" id="4b23c91b_1694">firstJob01</code> 步骤名称为 <code class="code" id="4b23c91b_1695">step01</code> 如果别的任务也叫这个名称的话，则会执行失败。启动项目，控制台打印如下</p><div class="code-block" data-lang="java"         >
Spring Batch 执行第一个步骤...
</div><p id="4b23c91b_1697">可以看到，定义的任务执行成功，数据库中也有响应的记录</p><p id="4b23c91b_1698">重启项目后，控制台并不会再次打印出任务执行日志，因为Job名称和 Step名称组成唯一，执行完的不可重复的任务，不会再次执行。</p></section><section class="chapter"><h2 id="4b23c91b_1699" data-toc="4b23c91b_1699"   >多步骤任务</h2><p id="4b23c91b_1700">一般情况下一个复杂的任务包含多个任务步骤，下列代码所示多步骤任务创建：</p><div class="code-block" data-lang="java"         >
package com.liao.job;

/**
 * &lt;p&gt;
 * Spring Batch 多步骤任务
 * &lt;/p&gt;
 *
 * @author LiAo
 * @since 2023-05-11
 */
@Component
public class MultiStepJobDemo {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    private Job multiStepJob01() {
        return jobBuilderFactory.get(&quot;multiStepJob01&quot;)
                .start(step01())
                .next(step02())
                .next(step03())
                .build();
    }

    public Step step01() {
        return stepBuilderFactory.get(&quot;step01&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;MultiStepJobDemo Spring Batch 多步骤任务测试 步骤1 step01...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    public Step step02() {
        return stepBuilderFactory.get(&quot;step02&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;MultiStepJobDemo Spring Batch 多步骤任务测试 步骤1 step02...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    public Step step03() {
        return stepBuilderFactory.get(&quot;step03&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;MultiStepJobDemo Spring Batch 多步骤任务测试 步骤1 step03...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }
}
</div><p id="4b23c91b_1702">上面代码中，我们通过* <code class="code" id="4b23c91b_1703">step1()</code><span class="emphasis" id="4b23c91b_1704">、</span><code class="code" id="4b23c91b_1705">step2()</code><span class="emphasis" id="4b23c91b_1706">和</span><code class="code" id="4b23c91b_1707">step3()</code><span class="emphasis" id="4b23c91b_1708">三个方法创建了三个步骤。Job里要使用这些步骤，只需要通过</span><code class="code" id="4b23c91b_1709">JobBuilderFactory</code><span class="emphasis" id="4b23c91b_1710">的</span><code class="code" id="4b23c91b_1711">start</code><span class="emphasis" id="4b23c91b_1712">方法指定第一个步骤，然后通过</span><code class="code" id="4b23c91b_1713">next</code> *方法不断地指定下一个步骤。</p><p id="4b23c91b_1714">启动项目打印结果如下：</p><div class="code-block" data-lang="java"         >
MultiStepJobDemo Spring Batch 多步骤任务测试 步骤1 step01...
2023-05-11 16:31:05.877  INFO 2948 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [step01] executed in 18ms
2023-05-11 16:31:05.889  INFO 2948 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [step02]
MultiStepJobDemo Spring Batch 多步骤任务测试 步骤1 step02...
2023-05-11 16:31:05.901  INFO 2948 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [step02] executed in 12ms
2023-05-11 16:31:05.917  INFO 2948 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [step03]
MultiStepJobDemo Spring Batch 多步骤任务测试 步骤1 step03...
2023-05-11 16:31:05.928  INFO 2948 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [step03] executed in 11ms
2023-05-11 16:31:05.936  INFO 2948 --- [           main] o.s.b.c.l.support.SimpleJobLauncher      : Job: [SimpleJob: [name=multiStepJob01]] completed with the following parameters: [{}] and the following status: [COMPLETED] in 88ms
</div><p id="4b23c91b_1716">三个步骤执行成功</p></section><section class="chapter"><h2 id="4b23c91b_1717" data-toc="4b23c91b_1717"   >多步骤任务状态判断</h2><p id="4b23c91b_1718">多步骤任务在执行过程中也可以通过上一个步骤的执行状态来判定是否执行下一个步骤，修改上面 <code class="code" id="4b23c91b_1719">multiStepJob01</code> 函数的代码如下所示：</p><div class="code-block" data-lang="java"         >
		@Bean
    public Job multiStepJob01() {
        return jobBuilderFactory.get(&quot;multiStepJob01&quot;)
                .start(step01())
                .on(ExitStatus.COMPLETED.getExitCode()).to(step02())
                .from(step02())
                .on(ExitStatus.COMPLETED.getExitCode()).to(step03())
                .from(step03()).end()
                .build();
    }

    public Step step01() {
        return stepBuilderFactory.get(&quot;step01&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;MultiStepJobDemo Spring Batch 多步骤任务测试 步骤1 step01...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    public Step step02() {
        return stepBuilderFactory.get(&quot;step02&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;MultiStepJobDemo Spring Batch 多步骤任务测试 步骤2 step02...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    public Step step03() {
        return stepBuilderFactory.get(&quot;step03&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;MultiStepJobDemo Spring Batch 多步骤任务测试 步骤3 step03...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }
</div><p id="4b23c91b_1721"><code class="code" id="4b23c91b_1722">multiStepJob01</code> 方法的含义是：首先执行 step01，当 step01 执行状态为完成时，接着执行 step02 , 当 step02 执行状态为完成时，接着执行step3。 <code class="code" id="4b23c91b_1723">ExitStatus.COMPLETED</code>常量表示任务顺利执行完毕，正常退出。</p></section><section class="chapter"><h2 id="4b23c91b_1724" data-toc="4b23c91b_1724"   >注意</h2><p id="4b23c91b_1725">上述代码在 <code class="code" id="4b23c91b_1726">Spring Batch 4.2.5.RELEASE</code> 及其以上时，不会执行 <code class="code" id="4b23c91b_1727">**step03**</code> 步骤，因为从 <code class="code" id="4b23c91b_1728">Spring Batch 4.2.5.RELEASE</code> 开始， <code class="code" id="4b23c91b_1729">org.springframework.batch.core.job.builder.FlowBuilder&lt;Q&gt;.createState(Object)</code> 函数做了如下变动：</p><div class="code-block" data-lang="java"         >
states.put(input, new StepState(prefix + step.getName(), step));                // Spring Batch 4.2.4.RELEASE 及其以前
states.put(input, new StepState(prefix + &quot;step&quot; + (stepCounter++), step));      // Spring Batch 4.2.5.RELEASE 及其以后
</div></section><section class="chapter"><h2 id="spring-batch-4-2-5-release" data-toc="spring-batch-4-2-5-release"   >Spring Batch 4.2.5.RELEASE 代码变动</h2><p id="4b23c91b_1731">上述代码的变动，导致 <code class="code" id="4b23c91b_1732">from()</code> 函数中构建的内容只能是 <code class="code" id="4b23c91b_1733">Spring IoC</code> 容器中的，否则就会失效，导致 <code class="code" id="4b23c91b_1734">from</code> 往下的流程不执行，所以上述 <a href="https://www.notion.so/057885c326f749258e43b3927c22037b?pvs=21" id="4b23c91b_1735"   data-external="true" rel="noopener noreferrer" >**多步骤状态判断</a>** 代码需要做如下变动</p><div class="code-block" data-lang="java"         >
package com.liao.job;

/**
 * &lt;p&gt;
 * Spring Batch 多步骤任务
 * &lt;/p&gt;
 *
 * @author LiAo
 * @since 2023-05-11
 */
@Configuration
public class MultiStepJobDemo {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    public Job multiStepJob02(@Qualifier(&quot;multiStepJobStep01&quot;) Step stop01,
                              @Qualifier(&quot;multiStepJobStep02&quot;) Step step02,
                              @Qualifier(&quot;multiStepJobStep03&quot;) Step step03) {
        return jobBuilderFactory.get(&quot;multiStepJob02&quot;)
                .start(stop01)
                .on(ExitStatus.COMPLETED.getExitCode()).to(step02)
                .from(step02())
                .on(ExitStatus.COMPLETED.getExitCode()).to(step03)
                .from(step03).end()
                .build();
    }

    @Bean(&quot;multiStepJobStep01&quot;)
    public Step step01() {
        return stepBuilderFactory.get(&quot;step01&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;MultiStepJobDemo Spring Batch 多步骤任务测试 步骤1 step01...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    @Bean(&quot;multiStepJobStep02&quot;)
    public Step step02() {
        return stepBuilderFactory.get(&quot;step02&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;MultiStepJobDemo Spring Batch 多步骤任务测试 步骤2 step02...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    @Bean(&quot;multiStepJobStep03&quot;)
    public Step step03() {
        return stepBuilderFactory.get(&quot;step03&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;MultiStepJobDemo Spring Batch 多步骤任务测试 步骤3 step03...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }
}
</div><p id="4b23c91b_1737">上述代码将 Step 步骤通过 <code class="code" id="4b23c91b_1738">@Bean</code> 注解注册到 <code class="code" id="4b23c91b_1739">Spring IoC</code> 容器中，然后再进行 Job 任务的构建</p><p id="4b23c91b_1740"><code class="code" id="4b23c91b_1741">Spring Batch 4.2.4.RELEASE</code> 及其之前版本支持 <span class="control" id="4b23c91b_1742">函数名称</span> 和 <span class="control" id="4b23c91b_1743">容器对象</span> 两种方式的调用，从 <code class="code" id="4b23c91b_1744">Spring Batch 4.2.5.RELEASE</code> 版本开始，只支持容器对象这一种方式。 <code class="code" id="4b23c91b_1745">Spring Boot</code> 从 <code class="code" id="4b23c91b_1746">2.3.7.RELEASE</code> 版本开始使用 <code class="code" id="4b23c91b_1747">Spring Batch 4.2.5.RELEASE</code></p></section><section class="chapter"><h2 id="flow" data-toc="flow"   >Flow 任务</h2><p id="4b23c91b_1748">Flow 的作用是将多个 step 步骤组装起来，然后再组装到任务Job中。下列代码是 Flow 任务示例：</p><div class="code-block" data-lang="java"         >
package com.liao.job;

/**
 * &lt;p&gt;
 * Spring Batch Flow 流程任务测试
 * &lt;/p&gt;
 *
 * @author LiAo
 * @since 2023-05-12
 */
@Configuration
public class FlowJobDemo {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    public Job flowJob01(@Qualifier(&quot;flowJobFlow01&quot;) Flow flow01,
                         @Qualifier(&quot;flowJobStep03&quot;) Step step03) {
        return jobBuilderFactory.get(&quot;flowJob&quot;)
                .start(flow01)
                .next(step03).end().build();
    }

    @Bean(&quot;flowJobStep01&quot;)
    public Step step01() {
        return stepBuilderFactory.get(&quot;step01&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;FlowJobDemo epJobDemo Spring Batch Flow任务测试 步骤1 step01...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    @Bean(&quot;flowJobStep02&quot;)
    public Step step02() {
        return stepBuilderFactory.get(&quot;step02&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;FlowJobDemo Spring Batch Flow任务测试 步骤2 step02...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    @Bean(&quot;flowJobStep03&quot;)
    public Step step03() {
        return stepBuilderFactory.get(&quot;step03&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;FlowJobDemo Spring Batch Flow任务测试 步骤3 step03...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    @Bean(&quot;flowJobFlow01&quot;)
    public Flow flow01(@Qualifier(&quot;flowJobStep01&quot;) Step step01,
                       @Qualifier(&quot;flowJobStep02&quot;) Step step02) {
        return new FlowBuilder&lt;Flow&gt;(&quot;flow01&quot;)
                .start(step01)
                .next(step02)
                .build();
    }
}
</div><p id="4b23c91b_1750">上述代码通过 <code class="code" id="4b23c91b_1751">FlowBuilder</code> 将步骤 step01 和 step02 组合在一起，然后再将其赋给任务 flowJob ，使用 Flow 和 Step 构建 Job 的区别是：Job 任务流程中包含 Flow 任务流程时，在调用 <code class="code" id="4b23c91b_1752">build()</code> 方法之前需要调用 <code class="code" id="4b23c91b_1753">end()</code> 方法</p><p id="4b23c91b_1754">运行代码执行结果如下所示：</p><div class="code-block" data-lang="java"         >
FlowJobDemo Spring Batch Flow任务测试 步骤1 step01...
2023-05-12 15:03:49.575  INFO 23988 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [step01] executed in 19ms
2023-05-12 15:03:49.591  INFO 23988 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [step02]
FlowJobDemo Spring Batch Flow任务测试 步骤2 step02...
2023-05-12 15:03:49.602  INFO 23988 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [step02] executed in 10ms
2023-05-12 15:03:49.621  INFO 23988 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [step03]
FlowJobDemo Spring Batch Flow任务测试 步骤3 step03...
2023-05-12 15:03:49.633  INFO 23988 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [step03] executed in 12ms
</div></section><section class="chapter"><h2 id="4b23c91b_1756" data-toc="4b23c91b_1756"   >并行任务</h2><p id="4b23c91b_1757">Spring Batch 任务中除了串行执行任务（一个执行结束执行下一个），也可以并行执行（两个一起执行），并执行在特定的业务下可以提高执行的效率，将任务并行化有如下两个步骤：</p><ol class="list _decimal" id="4b23c91b_1758" type="1"><li class="list__item" id="4b23c91b_1759"><p>将步骤 Step 转换为 Flow</p></li><li class="list__item" id="4b23c91b_1760"><p>在任务中指定需要并行的 Flow</p></li></ol><p id="4b23c91b_1761">并行任务如下所示：</p><div class="code-block" data-lang="java"         >
package com.liao.job;

/**
 * &lt;p&gt;
 * Spring Batch 并行任务测试
 * &lt;/p&gt;
 *
 * @author LiAo
 * @since 2023-05-12
 */
@Configuration
public class SplitJobDemo {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;
    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    public Job splitJob01(@Qualifier(&quot;splitJobFlow01&quot;) Flow flow01,
                          @Qualifier(&quot;splitJobFlow02&quot;) Flow flow02) {
        return jobBuilderFactory.get(&quot;splitJob&quot;)
                .start(flow01)
                .split(new SimpleAsyncTaskExecutor()).add(flow02)
                .end().build();
    }

    @Bean(&quot;splitJobStep01&quot;)
    public Step step01() {
        return stepBuilderFactory.get(&quot;step01&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;SplitJobDemo Spring Batch Split任务测试 步骤1 step01...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    @Bean(&quot;splitJobStep02&quot;)
    public Step step02() {
        return stepBuilderFactory.get(&quot;step02&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;SplitJobDemo Spring Batch Split任务测试 步骤2 step02...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    @Bean(&quot;splitJobStep03&quot;)
    public Step step03() {
        return stepBuilderFactory.get(&quot;step03&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;SplitJobDemo Spring Batch Split任务测试 步骤3 step03...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    @Bean(&quot;splitJobFlow01&quot;)
    public Flow flow01(@Qualifier(&quot;splitJobStep01&quot;) Step step01,
                       @Qualifier(&quot;splitJobStep02&quot;) Step step02) {
        return new FlowBuilder&lt;Flow&gt;(&quot;flow01&quot;)
                .start(step01)
                .next(step02)
                .build();
    }

    @Bean(&quot;splitJobFlow02&quot;)
    public Flow flow02(@Qualifier(&quot;splitJobStep03&quot;) Step step03) {
        return new FlowBuilder&lt;Flow&gt;(&quot;flow02&quot;)
                .start(step03)
                .build();
    }
}
</div><p id="4b23c91b_1763">上述代码创建了两个 Flow：flow01 包含 step01 和 step02，flow02 包含 step03，然后通过 <code class="code" id="4b23c91b_1764">JobBuilderFactory.split()</code> 方法，指定一个异步执行器，将 flow01 和 flow02 并行执行。</p><p id="4b23c91b_1765">启动项目日志打印如下：</p><div class="code-block" data-lang="java"         >
2023-05-12 15:46:02.747  INFO 26068 --- [cTaskExecutor-1] o.s.batch.core.job.SimpleStepHandler     : Executing step: [step03]
2023-05-12 15:46:02.750  INFO 26068 --- [cTaskExecutor-2] o.s.batch.core.job.SimpleStepHandler     : Executing step: [step01]
SplitJobDemo Spring Batch Split任务测试 步骤3 step03...
SplitJobDemo Spring Batch Split任务测试 步骤1 step01...
2023-05-12 15:46:02.768  INFO 26068 --- [cTaskExecutor-1] o.s.batch.core.step.AbstractStep         : Step: [step03] executed in 21ms
2023-05-12 15:46:02.768  INFO 26068 --- [cTaskExecutor-2] o.s.batch.core.step.AbstractStep         : Step: [step01] executed in 18ms
2023-05-12 15:46:02.788  INFO 26068 --- [cTaskExecutor-2] o.s.batch.core.job.SimpleStepHandler     : Executing step: [step02]
SplitJobDemo Spring Batch Split任务测试 步骤2 step02...
2023-05-12 15:46:02.801  INFO 26068 --- [cTaskExecutor-2] o.s.batch.core.step.AbstractStep         : Step: [step02] executed in 12ms
</div><p id="4b23c91b_1767">可以看到 step03 和 step01 先后执行，然后才执行 step02 说明并行任务执行成功，并行任务的顺序不能百分百确定，因为线程的调度具有不确定性</p></section><section class="chapter"><h2 id="4b23c91b_1768" data-toc="4b23c91b_1768"   >任务决策器</h2><p id="4b23c91b_1769">决策器用于决定任务在不同情况下运行不同流程，若今天是周末执行 step01 步骤，否则就执行 step02 步骤。</p></section><section class="chapter"><h2 id="4b23c91b_1770" data-toc="4b23c91b_1770"   >决策器创建</h2><p id="4b23c91b_1771">决策器使用之前需要创建一个决策器类，并实现 <code class="code" id="4b23c91b_1772">org.springframework.batch.core.job.flow</code> 包下的 <code class="code" id="4b23c91b_1773">JobExecutionDecider</code> 接口的 <code class="code" id="4b23c91b_1774">decide</code> 方法：</p><div class="code-block" data-lang="java"         >
package com.liao.decider;

/**
 * &lt;p&gt;
 * Spring Batch 任务决策器
 * &lt;/p&gt;
 *
 * @author LiAo
 * @since 2023-05-12
 */
@Component
public class MyDecider implements JobExecutionDecider {

    /**
     * 自定义任务决策器
     *
     * @param jobExecution  a job execution
     * @param stepExecution the latest step execution (maybe {@code null})
     * @return the exit status code
     */
    @Override
    public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {
        LocalDate now = LocalDate.now();
        DayOfWeek dayOfWeek = now.getDayOfWeek();
        if (dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY) {
            return new FlowExecutionStatus(&quot;weekend&quot;);
        } else {
            return new FlowExecutionStatus(&quot;workingDay&quot;);
        }
    }
}
</div><p id="4b23c91b_1776">MyDecider 类实现了 <code class="code" id="4b23c91b_1777">JobExecutionDecider</code> 接口的 <code class="code" id="4b23c91b_1778">decide</code> 方法，改方法返回一个 <code class="code" id="4b23c91b_1779">FlowExecutionStatus</code> ，上述代码逻辑为：若今天为周末则返回 <code class="code" id="4b23c91b_1780">FlowExecutionStatus(&quot;weekend&quot;)</code> 否则返回 <code class="code" id="4b23c91b_1781">FlowExecutionStatus(&quot;workingDay&quot;)</code></p></section><section class="chapter"><h2 id="4b23c91b_1782" data-toc="4b23c91b_1782"   >决策器使用</h2><div class="code-block" data-lang="java"         >
package com.liao.job;

/**
 * &lt;p&gt;
 * 测试 Spring Batch 任务决策器
 * &lt;/p&gt;
 *
 * @author LiAo
 * @since 2023-05-12
 */
@Configuration
public class DeciderJobDemo {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Autowired
    private MyDecider myDecider;

    @Bean
    public Job deciderJob01(@Qualifier(&quot;step01&quot;) Step step01,
                            @Qualifier(&quot;step02&quot;) Step step02,
                            @Qualifier(&quot;step03&quot;) Step step03,
                            @Qualifier(&quot;step04&quot;) Step step04) {
        return jobBuilderFactory.get(&quot;deciderJob01&quot;)
                .start(step01)
                .next(myDecider)
                .from(myDecider)
                .on(&quot;weekend&quot;).to(step02)
                .from(myDecider)
                .on(&quot;workingDay&quot;).to(step03)
                .from(step03)
                .on(&quot;*&quot;).to(step04)
                .end().build();
    }

    @Bean(&quot;step01&quot;)
    public Step step01() {
        return stepBuilderFactory.get(&quot;step01&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;DeciderJobDemo Spring Batch Decider Split任务测试 步骤1 step01...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    @Bean(name = &quot;step02&quot;)
    public Step step02() {
        return stepBuilderFactory.get(&quot;step02&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;DeciderJobDemo Spring Batch Decider Split任务测试 weekend 步骤2 step02...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    @Bean(name = &quot;step03&quot;)
    public Step step03() {
        return stepBuilderFactory.get(&quot;liao03&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;DeciderJobDemo Spring Batch Decider Split任务测试 workingDay 步骤3 step03...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }

    @Bean(name = &quot;step04&quot;)
    public Step step04() {
        return stepBuilderFactory.get(&quot;step04&quot;).tasklet((contribution, chunkContext) -&gt; {
            System.out.println(&quot;DeciderJobDemo Spring Batch Decider Split任务测试 * 步骤4 step04...&quot;);
            return RepeatStatus.FINISHED;
        }).build();
    }
}
</div><p id="4b23c91b_1784">上述代码的含义是：名为 <code class="code" id="4b23c91b_1785">deciderJob01</code> 的任务首先执行 <code class="code" id="4b23c91b_1786">step01</code> 然后指定自定义的决策器，若决策器返回 <code class="code" id="4b23c91b_1787">weekend</code> 则执行 <code class="code" id="4b23c91b_1788">step02</code> ，若是返回 <code class="code" id="4b23c91b_1789">workingDay</code> 则执行 <code class="code" id="4b23c91b_1790">step03</code> ，若是执行了 <code class="code" id="4b23c91b_1791">step03</code> 则无论结果如何都执行 <code class="code" id="4b23c91b_1792">step04</code></p><p id="4b23c91b_1793">启动项目，任务执行结果如下所示：</p><div class="code-block" data-lang="java"         >
2023-05-17 10:37:42.281  INFO 10640 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [step01]
MultiStepJobDemo Spring Batch Decider Split任务测试 步骤1 step01...
2023-05-17 10:37:42.306  INFO 10640 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [step01] executed in 23ms
2023-05-17 10:37:42.330  INFO 10640 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [liao03]
MultiStepJobDemo Spring Batch Decider Split任务测试 workingDay 步骤3 step03...
2023-05-17 10:37:42.345  INFO 10640 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [liao03] executed in 15ms
2023-05-17 10:37:42.365  INFO 10640 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [step04]
MultiStepJobDemo Spring Batch Decider Split任务测试 * 步骤4 step04...
</div><p id="4b23c91b_1795">因为上述代码的执行日期为 <code class="code" id="4b23c91b_1796">2023-05-17</code> 是周三 所以执行了 step01、step03、step04 这三个步骤。</p></section><section class="chapter"><h2 id="4b23c91b_1797" data-toc="4b23c91b_1797"   >嵌套任务</h2><p id="4b23c91b_1798">任务 Job 除了可以由 Step 个 Flow 构成之外，还可以将 Job 转为特殊的 Step，然后再构建进另一个任务 Job ，这就是嵌套任务：</p><div class="code-block" data-lang="java"         >
package com.liao.job;

/**
 * &lt;p&gt;
 * Spring Batch 任务嵌套测试
 * &lt;/p&gt;
 *
 * @author LiAo
 * @since 2023-05-17
 */
@Configuration
public class NestedJobDemo {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private JobRepository jobRepository;

    @Autowired
    private PlatformTransactionManager platformTransactionManager;

    @Bean
    public Job parentJob(@Qualifier(&quot;nestedChildJobOneStep&quot;) Step childJobOneStep,
                         @Qualifier(&quot;nestedChildJobTowStep&quot;) Step childJobTowStep) {
        return jobBuilderFactory.get(&quot;parentJob&quot;)
                .start(childJobOneStep)
                .next(childJobTowStep)
                .build();
    }

    // 将任务转为特殊的 Step
    @Bean(&quot;nestedChildJobOneStep&quot;)
    public Step childJobOneStep(@Qualifier(&quot;nestedJobChildJobOne&quot;) Job childJobOne) {
        return new JobStepBuilder(new StepBuilder(&quot;nestedChildJobOneStep&quot;))
                .job(childJobOne)
                .launcher(jobLauncher)
                .repository(jobRepository)
                .transactionManager(platformTransactionManager)
                .build();
    }

    // 将任务转为特殊的 Step
    @Bean(&quot;nestedChildJobTowStep&quot;)
    public Step childJobTowStep(@Qualifier(&quot;nestedJobChildJobTow&quot;) Job childJobTwo) {
        return new JobStepBuilder(new StepBuilder(&quot;nestedChildJobTwoStep&quot;))
                .job(childJobTwo)
                .launcher(jobLauncher)
                .repository(jobRepository)
                .transactionManager(platformTransactionManager)
                .build();
    }

    // 嵌套子任务1
    @Bean(&quot;nestedJobChildJobOne&quot;)
    public Job childJobOne() {
        return jobBuilderFactory.get(&quot;nestedJobChildJobOne&quot;)
                .start(
                        stepBuilderFactory.get(&quot;nestedJobChildJobOneStep&quot;)
                                .tasklet((stepContribution, chunkContext) -&gt; {
                                    System.out.println(&quot;NestedJobDemo Spring Batch Nested 嵌套子任务执行 childJobOne 任务1 ...&quot;);
                                    return RepeatStatus.FINISHED;
                                }).build()
                ).build();
    }

    // 嵌套子任务2
    @Bean(&quot;nestedJobChildJobTow&quot;)
    public Job childJobTwo() {
        return jobBuilderFactory.get(&quot;nestedJobChildJobTwo&quot;)
                .start(
                        stepBuilderFactory.get(&quot;nestedJobChildJobTwoStep&quot;)
                                .tasklet((stepContribution, chunkContext) -&gt; {
                                    System.out.println(&quot;NestedJobDemo Spring Batch Nested 嵌套子任务执行 childJobTwo 任务2 ...&quot;);
                                    return RepeatStatus.FINISHED;
                                }).build()
                ).build();
    }
}
</div><p id="4b23c91b_1800">上述代码首先通过 <code class="code" id="4b23c91b_1801">childJobOne()</code> 和 <code class="code" id="4b23c91b_1802">childJobTwo()</code> 函数构建了两个普通任务，分别为 <code class="code" id="4b23c91b_1803">nestedJobChildJobOne</code> 和 <code class="code" id="4b23c91b_1804">nestedJobChildJobTow</code> ，然后在 <code class="code" id="4b23c91b_1805">childJobOneStep()</code> 函数中，通过 <code class="code" id="4b23c91b_1806">org.springframework.batch.core.step.builder.JobStepBuider</code> 构建了一个名为 <code class="code" id="4b23c91b_1807">nestedChildJobTwoStep</code> 的特殊 Step， <code class="code" id="4b23c91b_1808">JobStepBuilder</code> 望名知意，它是一个 <code class="code" id="4b23c91b_1809">Job</code> 类型的 <code class="code" id="4b23c91b_1810">Setp</code> 构建器，可以将 Job 构建为 Step，在构建的时候，需要传入 任务执行器 <code class="code" id="4b23c91b_1811">org.springframework.batch.core.launch.JobLauncher</code> 和 任务仓库 <code class="code" id="4b23c91b_1812">org.springframework.batch.core.repository.JobRepository</code> 以及事务管理器 <code class="code" id="4b23c91b_1813">org.springframework.transaction.PlatformTransactionManager</code></p><p id="4b23c91b_1814">将转换好的特殊步骤构建进最终的任务 <code class="code" id="4b23c91b_1815">parentJob</code> 中即可</p><p id="4b23c91b_1816">配置好后运行代码如下所示：</p><div class="code-block" data-lang="java"         >
NestedJobDemo Spring Batch Nested 嵌套子任务执行 childJobOne 任务1 ...
2023-05-17 11:19:09.088  INFO 18168 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [nestedJobChildJobOneStep] executed in 15ms
2023-05-17 11:19:09.098  INFO 18168 --- [           main] o.s.b.c.l.support.SimpleJobLauncher      : Job: [SimpleJob: [name=nestedJobChildJobOne]] completed with the following parameters: [{}] and the following status: [COMPLETED] in 34ms
2023-05-17 11:19:09.129  INFO 18168 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [nestedChildJobOneStep] executed in 87ms
2023-05-17 11:19:09.144  INFO 18168 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [nestedChildJobTwoStep]
2023-05-17 11:19:09.158  INFO 18168 --- [           main] o.s.b.c.l.support.SimpleJobLauncher      : Job: [SimpleJob: [name=nestedJobChildJobTwo]] launched with the following parameters: [{}]
2023-05-17 11:19:09.172  INFO 18168 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [nestedJobChildJobTwoStep]
NestedJobDemo Spring Batch Nested 嵌套子任务执行 childJobTwo 任务2 ...
```..</div></section><div class="last-modified"> Last modified: 24 一月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="string.html">使用场景</a>   <a class="navigation-links__next" href="读取数据.html">读取数据</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>